<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ExcelSeeker</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <div class="theme-switch">
      <label class="switch">
        <input type="checkbox" id="themeToggle" />
        <span class="slider round"></span>
      </label>
      <span class="theme-label">Dark Mode</span>
    </div>

    <div class="container">
      <header>
        <h1>ExcelSeeker</h1>
        <p>Search through Excel files with ease</p>
      </header>

      <main>
        <div class="upload-section">
          <form id="searchForm" enctype="multipart/form-data">
            <div class="search-type">
              <label>How would you like to search?</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input
                    type="radio"
                    id="singleFile"
                    name="searchType"
                    value="file"
                    checked
                  />
                  <label for="singleFile">
                    <i class="icon">üìÑ</i>
                    Single File
                  </label>
                  <span class="check-icon">‚úì</span>
                </div>
                <div class="radio-option">
                  <input
                    type="radio"
                    id="folder"
                    name="searchType"
                    value="folder"
                  />
                  <label for="folder">
                    <i class="icon">üìÅ</i>
                    Folder
                  </label>
                  <span class="check-icon">‚úì</span>
                </div>
              </div>
            </div>

            <div id="fileInput" class="file-input">
              <label>Select Excel File</label>
              <div class="custom-file-input">
                <input
                  type="file"
                  id="file"
                  name="file"
                  accept=".xls"
                  required
                />
                <label for="file" class="custom-file-label">
                  <span id="fileNameDisplay">No file chosen</span>
                  <div class="browse-btn">Browse</div>
                </label>
              </div>
            </div>

            <div id="folderInput" class="file-input hidden">
              <label for="folderPath">Select Folder</label>
              <div class="folder-input-group">
                <input
                  type="text"
                  id="folderPath"
                  name="folderPath"
                  placeholder="Choose a folder containing .xls files"
                  readonly
                />
                <button
                  type="button"
                  id="selectFolderBtn"
                  onclick="selectFolder()"
                >
                  Browse...
                </button>
              </div>
              <p class="help-text">
                All .xls files in the selected folder will be searched
              </p>
            </div>

            <div class="search-container">
              <input
                type="text"
                id="searchText"
                name="search_text"
                placeholder="Enter search text..."
                required
              />
              <div class="search-mode">
                <label class="radio-label">
                  <input
                    type="radio"
                    name="search_mode"
                    value="exact"
                    checked
                  />
                  <span>Exact phrase</span>
                </label>
                <label class="radio-label">
                  <input type="radio" name="search_mode" value="any" />
                  <span>Any keywords</span>
                </label>
                <label class="radio-label">
                  <input type="radio" name="search_mode" value="all" />
                  <span>All keywords</span>
                </label>
              </div>
            </div>

            <button type="submit">Search</button>
          </form>
        </div>

        <div id="loading" class="loading hidden">
          <div class="spinner"></div>
          <p>Searching...</p>
          <p id="progress" class="progress-text"></p>
          <div class="progress-bar-container">
            <div class="progress-bar"></div>
            <div class="progress-text">0%</div>
          </div>
          <button type="button" id="cancelSearch" class="cancel-button">
            Cancel Search
          </button>
        </div>

        <div class="results-section" id="resultsSection">
          <div class="results-header">
            <h2>Search Results</h2>
            <button
              type="button"
              onclick="clearSkipList()"
              class="secondary-button"
              title="Clear the list of skipped files"
            >
              Clear Skip List
            </button>
          </div>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>File</th>
                  <th>Sheet</th>
                  <th>Cell</th>
                  <th>Value</th>
                </tr>
              </thead>
              <tbody id="resultsBody"></tbody>
            </table>
          </div>
        </div>

        <div id="skippedFiles" class="skipped-files hidden">
          <h3>Skipped Files</h3>
          <div class="skipped-files-content">
            <ul id="skippedFilesList"></ul>
          </div>
          <button
            type="button"
            onclick="clearSkipList()"
            class="secondary-button"
          >
            Clear Skip List
          </button>
        </div>
      </main>
    </div>

    <script>
      // Theme toggle functionality
      const themeToggle = document.getElementById("themeToggle");
      const html = document.documentElement;

      // Check for saved theme preference
      const savedTheme = localStorage.getItem("theme") || "light";
      html.setAttribute("data-theme", savedTheme);
      themeToggle.checked = savedTheme === "dark";

      themeToggle.addEventListener("change", () => {
        const newTheme = themeToggle.checked ? "dark" : "light";
        html.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);
      });

      // Toggle between file and folder input
      document.querySelectorAll('input[name="searchType"]').forEach((radio) => {
        radio.addEventListener("change", (e) => {
          const fileInput = document.getElementById("fileInput");
          const folderInput = document.getElementById("folderInput");
          const fileElement = document.getElementById("file");
          const folderElement = document.getElementById("folderPath");

          if (e.target.value === "file") {
            fileInput.classList.remove("hidden");
            folderInput.classList.add("hidden");
            fileElement.required = true;
            folderElement.required = false;
          } else {
            fileInput.classList.add("hidden");
            folderInput.classList.remove("hidden");
            fileElement.required = false;
            folderElement.required = true;
          }
        });
      });

      async function handleFolderSearch(folderPath, searchText) {
        const loading = document.getElementById("loading");
        const progress = document.getElementById("progress");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarContainer = document.querySelector(
          ".progress-bar-container"
        );
        const progressText = document.querySelector(
          ".progress-bar-container .progress-text"
        );
        const resultsSection = document.getElementById("resultsSection");
        const cancelButton = document.getElementById("cancelSearch");

        // Show loading and progress bar
        loading.classList.remove("hidden");
        progressBarContainer.classList.remove("hidden");
        resultsSection.classList.add("hidden");
        progress.textContent = "Preparing to search...";
        progressBar.style.width = "0%";
        progressText.textContent = "0%";
        cancelButton.style.display = "block";

        try {
          // Clean up any existing connection
          if (activeEventSource) {
            activeEventSource.close();
            activeEventSource = null;
          }

          const url = new URL("/search_folder", window.location.origin);
          url.searchParams.append("folder_path", folderPath);
          url.searchParams.append("search_text", searchText);

          const eventSource = new EventSource(url.toString());
          handleEventSource(eventSource);
        } catch (error) {
          console.error("Error:", error);
          loading.classList.add("hidden");
          progressBarContainer.classList.add("hidden");
          showError(
            error.message || "An error occurred while processing the folder"
          );
        }
      }

      // Add error display function
      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error";
        errorDiv.textContent = message;

        const resultsSection = document.getElementById("resultsSection");
        resultsSection.insertAdjacentElement("beforebegin", errorDiv);

        // Remove error after 5 seconds
        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
      }

      function showMessage(message) {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message";
        messageDiv.textContent = message;

        const resultsSection = document.getElementById("resultsSection");
        resultsSection.insertAdjacentElement("beforebegin", messageDiv);

        // Remove message after 5 seconds
        setTimeout(() => {
          messageDiv.remove();
        }, 5000);
      }

      // Update the form submit handler
      document
        .getElementById("searchForm")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const form = e.target;
          const formData = new FormData(form);
          const loading = document.getElementById("loading");
          const progress = document.getElementById("progress");
          const resultsSection = document.getElementById("resultsSection");
          const searchType = formData.get("searchType");

          // Remove any existing error messages
          document
            .querySelectorAll(".error")
            .forEach((error) => error.remove());

          // Reset and show loading
          loading.classList.remove("hidden");
          resultsSection.classList.add("hidden");
          progress.textContent = "";

          try {
            if (searchType === "folder") {
              const folderPath = formData.get("folderPath");
              if (!folderPath) {
                throw new Error("Please select a folder");
              }
              await handleFolderSearch(folderPath, formData.get("search_text"));
            } else {
              const file = formData.get("file");
              if (!file || !file.name) {
                throw new Error("Please select a file");
              }

              const response = await fetch("/search", {
                method: "POST",
                body: formData,
              });

              const data = await response.json();

              if (!response.ok) {
                throw new Error(data.error || "An error occurred");
              }

              if (data.error) {
                throw new Error(data.error);
              }

              loading.classList.add("hidden");
              if (data && data.length > 0) {
                displayResults(data);
              } else {
                showError("No results found in the selected file.");
              }
            }
          } catch (err) {
            loading.classList.add("hidden");
            showError(
              err.message || "An error occurred while processing the request"
            );
          }
        });

      // Update displayResults function
      function displayResults(results) {
        const tbody = document.getElementById("resultsBody");
        const noResults = document.getElementById("noResults");
        tbody.innerHTML = "";

        if (!results || results.length === 0) {
          noResults.classList.remove("hidden");
          return;
        }

        noResults.classList.add("hidden");
        results.forEach((result) => {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>
              <a href="file://${escapeHtml(result.filepath)}" 
                 onclick="openFile('${escapeHtml(
                   result.filepath
                 )}'); return false;" 
                 class="file-link" 
                 title="Click to open file">
                ${escapeHtml(result.filename)}
              </a>
            </td>
            <td>${escapeHtml(result.sheet)}</td>
            <td>${escapeHtml(result.cell)}</td>
            <td>${escapeHtml(result.value)}</td>
          `;
          tbody.appendChild(row);
        });

        // Store results for sorting/filtering
        window.searchResults = results;
      }

      function openFile(filepath) {
        fetch("/open-file", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ filepath: filepath }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              showError(data.error);
            }
          })
          .catch((error) => {
            console.error("Error opening file:", error);
            showError("Failed to open file");
          });
      }

      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // Add this function for folder selection
      async function selectFolder() {
        try {
          const response = await fetch("http://localhost:3000/select-folder", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          const data = await response.json();
          if (data.path) {
            document.getElementById("folderPath").value = data.path;
          }
        } catch (error) {
          console.error("Error selecting folder:", error);
          // Show error in the UI
          const errorDiv = document.getElementById("error");
          errorDiv.textContent =
            "Failed to open folder selection dialog. Make sure the folder service is running.";
          errorDiv.classList.remove("hidden");
        }
      }

      // Add this: Update file name display
      document.getElementById("file").addEventListener("change", function (e) {
        const fileName = e.target.files[0]?.name || "No file chosen";
        document.getElementById("fileNameDisplay").textContent = fileName;
      });

      // Add debounce function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Update the filtering functionality
      document.addEventListener("DOMContentLoaded", function () {
        let currentSort = { column: null, direction: "asc" };
        const MIN_FILTER_LENGTH = 2; // Minimum characters before filtering
        let cachedResults = []; // Cache for filtered results

        // Sorting functionality
        document.querySelectorAll(".sortable").forEach((header) => {
          header.addEventListener("click", () => {
            const column = header.dataset.sort;

            // Update sort direction
            if (currentSort.column === column) {
              currentSort.direction =
                currentSort.direction === "asc" ? "desc" : "asc";
            } else {
              currentSort.column = column;
              currentSort.direction = "asc";
            }

            // Update sort icons
            document.querySelectorAll(".sort-icon").forEach((icon) => {
              icon.textContent = "‚Üï";
            });
            header.querySelector(".sort-icon").textContent =
              currentSort.direction === "asc" ? "‚Üë" : "‚Üì";

            // Sort and display results
            if (window.searchResults) {
              applyFiltersAndSort();
            }
          });
        });

        // Filtering functionality
        const filterInput = document.getElementById("filterInput");
        const filterColumn = document.getElementById("filterColumn");
        const resultsSection = document.getElementById("resultsSection");
        const tbody = document.getElementById("resultsBody");
        const noResults = document.querySelector(".no-results");

        function applyFiltersAndSort() {
          if (!window.searchResults) return;

          const filterText = filterInput.value.toLowerCase();
          const column = filterColumn.value;

          // Skip filtering if text is too short
          if (filterText.length > 0 && filterText.length < MIN_FILTER_LENGTH) {
            return;
          }

          // Start with all results if no filter, or use cached results
          let filteredResults =
            filterText.length >= MIN_FILTER_LENGTH
              ? cachedResults
              : [...window.searchResults];

          // Apply filter
          if (filterText.length >= MIN_FILTER_LENGTH) {
            filteredResults = window.searchResults.filter((result) => {
              if (column === "all") {
                // Optimize by checking length first and using early return
                return Object.values(result).some((value) => {
                  const strValue = String(value).toLowerCase();
                  return strValue.includes(filterText);
                });
              }
              return String(result[column]).toLowerCase().includes(filterText);
            });
            cachedResults = filteredResults; // Cache the filtered results
          }

          // Apply sort if needed
          if (currentSort.column) {
            filteredResults.sort((a, b) => {
              let valueA = String(a[currentSort.column]).toLowerCase();
              let valueB = String(b[currentSort.column]).toLowerCase();
              return currentSort.direction === "asc"
                ? valueA.localeCompare(valueB)
                : valueB.localeCompare(valueA);
            });
          }

          // Update UI
          updateResultsTable(filteredResults);
        }

        function updateResultsTable(results) {
          tbody.innerHTML = "";

          if (results.length === 0) {
            noResults.classList.remove("hidden");
            return;
          }

          noResults.classList.add("hidden");
          const fragment = document.createDocumentFragment();

          results.forEach((result) => {
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>${escapeHtml(result.filename)}</td>
              <td>${escapeHtml(result.sheet)}</td>
              <td>${escapeHtml(result.cell)}</td>
              <td>${escapeHtml(result.value)}</td>
            `;
            fragment.appendChild(row);
          });

          tbody.appendChild(fragment);
        }

        // Debounce the filter function
        const debouncedFilter = debounce(() => {
          applyFiltersAndSort();
        }, 300); // 300ms delay

        filterInput.addEventListener("input", () => {
          const filterText = filterInput.value.toLowerCase();

          // Clear results if filter text is too short
          if (filterText.length > 0 && filterText.length < MIN_FILTER_LENGTH) {
            tbody.innerHTML = "";
            noResults.classList.remove("hidden");
            noResults.textContent = `Please enter at least ${MIN_FILTER_LENGTH} characters to search`;
            return;
          }

          debouncedFilter();
        });

        filterColumn.addEventListener("change", () => {
          cachedResults = []; // Clear cache when column changes
          applyFiltersAndSort();
        });
      });

      document.addEventListener("DOMContentLoaded", function () {
        const form = document.getElementById("searchForm");
        form.addEventListener("submit", handleSubmit);

        // Setup file input change handler
        const fileInput = document.getElementById("fileInput");
        fileInput.addEventListener("change", function () {
          const label = document.querySelector(".file-label");
          label.textContent = this.files[0]
            ? this.files[0].name
            : "Choose file";
        });

        // Add cancel button click handler
        document
          .getElementById("cancelSearch")
          .addEventListener("click", function () {
            if (currentSearchId) {
              console.log(
                "Cancel button clicked, cancelling search:",
                currentSearchId
              );
              cancelSearch();
            }
          });
      });

      async function handleSubmit(event) {
        event.preventDefault();

        const searchText = document.getElementById("searchText").value.trim();
        const searchMode = document.querySelector(
          'input[name="search_mode"]:checked'
        ).value;
        const fileInput = document.getElementById("fileInput");
        const folderPath = document.getElementById("folderPath").value.trim();

        if (!searchText) {
          showError("Please enter search text");
          return;
        }

        // Show loading state and hide results
        const loadingDiv = document.getElementById("loading");
        loadingDiv.classList.remove("hidden");
        document.getElementById("resultsSection").classList.add("hidden");
        document.getElementById("error").style.display = "none";

        const formData = new FormData();
        formData.append("search_text", searchText);
        formData.append("search_mode", searchMode);

        try {
          if (folderPath) {
            await handleFolderSearch(folderPath, searchText);
          } else if (fileInput.files.length > 0) {
            formData.append("file", fileInput.files[0]);
            const response = await fetch("/search", {
              method: "POST",
              body: formData,
            });

            const data = await response.json();
            if (response.ok) {
              displayResults(data);
            } else {
              showError(data.error || "An error occurred while searching");
            }
            // Hide cancel button for single file search
            document.getElementById("cancelSearch").style.display = "none";
          } else {
            showError("Please select a file or folder to search");
          }
        } catch (error) {
          showError("An error occurred while searching");
          console.error("Search error:", error);
        }
      }

      // Global state
      let currentSearchId = null;
      let activeEventSource = null;

      function updateProgress(data) {
        const progressBar = document.querySelector(".progress-bar");
        const progressText = document.querySelector(".progress-text");
        const progress = (data.processed / data.total) * 100;
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${Math.round(progress)}%`;
      }

      function handleEventSource(eventSource) {
        activeEventSource = eventSource;
        const loadingDiv = document.getElementById("loading");
        const cancelButton = document.getElementById("cancelSearch");
        const progressText = document.getElementById("progress");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarText = document.querySelector(".progress-text");

        loadingDiv.classList.remove("hidden");
        cancelButton.style.display = "block";

        eventSource.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);
            console.log("SSE message received:", data);

            if (data.search_id) {
              currentSearchId = data.search_id;
              console.log("Search ID set:", currentSearchId);
              return; // Don't process further for search_id message
            }

            if (data.type === "progress") {
              // Update progress bar
              const progress = (data.processed / data.total) * 100;
              progressBar.style.width = `${progress}%`;
              progressBarText.textContent = `${Math.round(progress)}%`;

              // Update progress text
              let progressMsg = `Processing: ${data.current_file} (${data.processed}/${data.total} files`;
              if (typeof data.results_found === "number") {
                progressMsg += `, ${data.results_found} results found`;
              }
              if (data.skipped_files > 0) {
                progressMsg += `, ${data.skipped_files} files skipped`;
              }
              progressMsg += ")";
              progressText.textContent = progressMsg;
            } else if (data.type === "complete") {
              console.log("Search completed");
              displayResults(data.results);

              if (data.skipped_files && data.skipped_files.length > 0) {
                displaySkippedFiles(data.skipped_files);
              }

              progressText.textContent = `Completed: ${data.total_processed} files processed, ${data.total_results} results found, ${data.total_skipped} files skipped`;
              cleanupSearch();
            } else if (data.type === "cancelled") {
              console.log("Search cancelled");
              progressText.textContent = "Search cancelled";
              showMessage("Search cancelled by user");
              document.getElementById("resultsBody").innerHTML = "";
              cleanupSearch();
            } else if (data.error) {
              console.error("Search error:", data.error);
              showError(data.error);
              cleanupSearch();
            }
          } catch (error) {
            console.error("Error processing SSE message:", error);
            showError("Error processing search results");
            cleanupSearch();
          }
        };

        eventSource.onerror = function (error) {
          console.error("SSE error:", error);
          showError("Error receiving search progress updates");
          cleanupSearch();
        };
      }

      function cleanupSearch() {
        if (activeEventSource) {
          console.log("Closing event source");
          activeEventSource.close();
          activeEventSource = null;
        }

        const loadingDiv = document.getElementById("loading");
        const cancelButton = document.getElementById("cancelSearch");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarText = document.querySelector(".progress-text");

        loadingDiv.classList.add("hidden");
        cancelButton.style.display = "none";
        progressBar.style.width = "0%";
        progressBarText.textContent = "0%";
        currentSearchId = null;
      }

      async function cancelSearch() {
        if (!currentSearchId) {
          console.log("No active search to cancel");
          return;
        }

        console.log("Attempting to cancel search:", currentSearchId);
        document.getElementById("progress").textContent =
          "Cancelling search...";

        try {
          const response = await fetch(`/cancel-search/${currentSearchId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          const data = await response.json();
          console.log("Cancel response:", data);

          if (!response.ok) {
            showError(data.error || "Failed to cancel search");
            // Clean up anyway if the search is not found
            if (response.status === 404) {
              cleanupSearch();
            }
          } else {
            // Don't clean up here - wait for the cancelled event from SSE
            console.log("Cancel request successful");
          }
        } catch (error) {
          console.error("Error cancelling search:", error);
          showError("Failed to cancel search");
        }
      }

      function displaySkippedFiles(skippedFiles) {
        const skippedFilesDiv = document.getElementById("skippedFiles");
        const skippedFilesList = document.getElementById("skippedFilesList");
        skippedFilesList.innerHTML = "";

        skippedFiles.forEach((file) => {
          const li = document.createElement("li");
          li.className = "skipped-file-item";
          li.innerHTML = `
            <span class="file-name">${escapeHtml(file.file)}</span>
            <span class="file-reason">${escapeHtml(file.reason)}</span>
          `;
          skippedFilesList.appendChild(li);
        });

        skippedFilesDiv.classList.remove("hidden");
      }

      async function clearSkipList() {
        try {
          const response = await fetch("/skip-list", {
            method: "DELETE",
          });

          const data = await response.json();
          if (response.ok) {
            document.getElementById("skippedFiles").classList.add("hidden");
            showMessage("Skip list cleared successfully");
          } else {
            showError(data.error || "Failed to clear skip list");
          }
        } catch (error) {
          showError("Failed to clear skip list");
          console.error("Error clearing skip list:", error);
        }
      }
    </script>
  </body>
</html>
