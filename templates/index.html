<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ExcelSeeker</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <div class="theme-switch">
      <label class="switch">
        <input type="checkbox" id="themeToggle" />
        <span class="slider round"></span>
      </label>
      <span class="theme-label">Dark Mode</span>
    </div>

    <div class="container">
      <header>
        <h1>ExcelSeeker</h1>
        <p>Search through Excel files with ease</p>
      </header>

      <main>
        <div class="upload-section">
          <form id="searchForm" enctype="multipart/form-data">
            <div class="search-type">
              <label>How would you like to search?</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input
                    type="radio"
                    id="singleFile"
                    name="searchType"
                    value="file"
                    checked
                  />
                  <label for="singleFile">
                    <i class="icon">üìÑ</i>
                    Single File
                  </label>
                  <span class="check-icon">‚úì</span>
                </div>
                <div class="radio-option">
                  <input
                    type="radio"
                    id="folder"
                    name="searchType"
                    value="folder"
                  />
                  <label for="folder">
                    <i class="icon">üìÅ</i>
                    Folder
                  </label>
                  <span class="check-icon">‚úì</span>
                </div>
              </div>
            </div>

            <div id="fileInput" class="file-input">
              <label>Select Excel File</label>
              <div class="custom-file-input">
                <input
                  type="file"
                  id="file"
                  name="file"
                  accept=".xls"
                  required
                />
                <label for="file" class="custom-file-label">
                  <span id="fileNameDisplay">No file chosen</span>
                  <div class="browse-btn">Browse</div>
                </label>
              </div>
            </div>

            <div id="folderInput" class="file-input hidden">
              <label for="folderPath">Select Folder</label>
              <div class="folder-input-group">
                <input
                  type="text"
                  id="folderPath"
                  name="folderPath"
                  placeholder="Choose a folder containing .xls files"
                  readonly
                />
                <button
                  type="button"
                  id="selectFolderBtn"
                  onclick="selectFolder()"
                >
                  Browse...
                </button>
              </div>
              <p class="help-text">
                All .xls files in the selected folder will be searched
              </p>
            </div>

            <div class="search-input">
              <label for="search_text">Search Text</label>
              <input
                type="text"
                id="search_text"
                name="search_text"
                required
                placeholder="Enter text to search for..."
              />
            </div>

            <button type="submit">Search</button>
          </form>
        </div>

        <div id="loading" class="loading hidden">
          <div class="spinner"></div>
          <p>Searching...</p>
          <p id="progress" class="progress-text"></p>
          <div class="progress-bar-container hidden">
            <div class="progress-bar"></div>
            <div class="progress-text">0%</div>
          </div>
        </div>

        <div class="results-section hidden" id="resultsSection">
          <div class="results-controls">
            <div class="filter-group">
              <input
                type="text"
                id="filterInput"
                placeholder="Filter results..."
                class="filter-input"
              />
              <select id="filterColumn" class="filter-select">
                <option value="all">All Columns</option>
                <option value="filename">Filename</option>
                <option value="sheet">Sheet</option>
                <option value="cell">Cell</option>
                <option value="value">Value</option>
              </select>
            </div>
          </div>
          <div class="table-container">
            <table class="results-table">
              <thead>
                <tr>
                  <th data-sort="filename" class="sortable">
                    Filename <span class="sort-icon">‚Üï</span>
                  </th>
                  <th data-sort="sheet" class="sortable">
                    Sheet <span class="sort-icon">‚Üï</span>
                  </th>
                  <th data-sort="cell" class="sortable">
                    Cell <span class="sort-icon">‚Üï</span>
                  </th>
                  <th data-sort="value" class="sortable">
                    Value <span class="sort-icon">‚Üï</span>
                  </th>
                </tr>
              </thead>
              <tbody id="resultsBody">
                <!-- Results will be populated here -->
              </tbody>
            </table>
          </div>
          <div class="no-results hidden">No results found.</div>
        </div>
      </main>
    </div>

    <script>
      // Theme toggle functionality
      const themeToggle = document.getElementById("themeToggle");
      const html = document.documentElement;

      // Check for saved theme preference
      const savedTheme = localStorage.getItem("theme") || "light";
      html.setAttribute("data-theme", savedTheme);
      themeToggle.checked = savedTheme === "dark";

      themeToggle.addEventListener("change", () => {
        const newTheme = themeToggle.checked ? "dark" : "light";
        html.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);
      });

      // Toggle between file and folder input
      document.querySelectorAll('input[name="searchType"]').forEach((radio) => {
        radio.addEventListener("change", (e) => {
          const fileInput = document.getElementById("fileInput");
          const folderInput = document.getElementById("folderInput");
          const fileElement = document.getElementById("file");
          const folderElement = document.getElementById("folderPath");

          if (e.target.value === "file") {
            fileInput.classList.remove("hidden");
            folderInput.classList.add("hidden");
            fileElement.required = true;
            folderElement.required = false;
          } else {
            fileInput.classList.add("hidden");
            folderInput.classList.remove("hidden");
            fileElement.required = false;
            folderElement.required = true;
          }
        });
      });

      async function handleFolderSearch(folderPath, searchText) {
        const loading = document.getElementById("loading");
        const progress = document.getElementById("progress");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarContainer = document.querySelector(
          ".progress-bar-container"
        );
        const progressText = document.querySelector(
          ".progress-bar-container .progress-text"
        );
        const resultsSection = document.getElementById("resultsSection");
        let eventSource = null;

        // Show loading and progress bar
        loading.classList.remove("hidden");
        progressBarContainer.classList.remove("hidden");
        resultsSection.classList.add("hidden");
        progress.textContent = "Preparing to search...";
        progressBar.style.width = "0%";
        progressText.textContent = "0%";

        try {
          // Clean up any existing connection
          if (eventSource) {
            eventSource.close();
          }

          const url = new URL("/search_folder", window.location.origin);
          url.searchParams.append("folder_path", folderPath);
          url.searchParams.append("search_text", searchText);

          eventSource = new EventSource(url.toString());

          eventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);

              if (data.type === "progress") {
                const percent = Math.round((data.processed / data.total) * 100);
                progressBar.style.width = `${percent}%`;
                progressText.textContent = `${percent}%`;
                progress.textContent = `Processing: ${data.current_file} (${data.processed}/${data.total} files, ${data.found_results} results found)`;
              } else if (data.type === "complete") {
                eventSource.close();
                loading.classList.add("hidden");
                progressBarContainer.classList.add("hidden");

                if (data.results && data.results.length > 0) {
                  displayResults(data.results);
                } else {
                  showError("No results found in the processed files.");
                }
              } else if (data.type === "error") {
                eventSource.close();
                loading.classList.add("hidden");
                progressBarContainer.classList.add("hidden");
                showError(
                  data.message || "An error occurred while processing files."
                );
              }
            } catch (error) {
              console.error("Error parsing SSE data:", error);
              eventSource.close();
              loading.classList.add("hidden");
              progressBarContainer.classList.add("hidden");
              showError("Error processing folder data");
            }
          };

          eventSource.onerror = (error) => {
            console.error("SSE Error:", error);
            eventSource.close();
            loading.classList.add("hidden");
            progressBarContainer.classList.add("hidden");
            showError("Error processing folder: Connection failed");
          };

          // Add cleanup on page unload
          window.addEventListener("beforeunload", () => {
            if (eventSource) {
              eventSource.close();
            }
          });
        } catch (error) {
          console.error("Error:", error);
          loading.classList.add("hidden");
          progressBarContainer.classList.add("hidden");
          showError(
            error.message || "An error occurred while processing the folder"
          );
        }
      }

      // Add error display function
      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error";
        errorDiv.textContent = message;

        const resultsSection = document.getElementById("resultsSection");
        resultsSection.insertAdjacentElement("beforebegin", errorDiv);

        // Remove error after 5 seconds
        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
      }

      // Update the form submit handler
      document
        .getElementById("searchForm")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const form = e.target;
          const formData = new FormData(form);
          const loading = document.getElementById("loading");
          const progress = document.getElementById("progress");
          const resultsSection = document.getElementById("resultsSection");
          const searchType = formData.get("searchType");

          // Remove any existing error messages
          document
            .querySelectorAll(".error")
            .forEach((error) => error.remove());

          // Reset and show loading
          loading.classList.remove("hidden");
          resultsSection.classList.add("hidden");
          progress.textContent = "";

          try {
            if (searchType === "folder") {
              const folderPath = formData.get("folderPath");
              if (!folderPath) {
                throw new Error("Please select a folder");
              }
              await handleFolderSearch(folderPath, formData.get("search_text"));
            } else {
              const file = formData.get("file");
              if (!file || !file.name) {
                throw new Error("Please select a file");
              }

              const response = await fetch("/search", {
                method: "POST",
                body: formData,
              });

              const data = await response.json();

              if (!response.ok) {
                throw new Error(data.error || "An error occurred");
              }

              if (data.error) {
                throw new Error(data.error);
              }

              loading.classList.add("hidden");
              if (data && data.length > 0) {
                displayResults(data);
              } else {
                showError("No results found in the selected file.");
              }
            }
          } catch (err) {
            loading.classList.add("hidden");
            showError(
              err.message || "An error occurred while processing the request"
            );
          }
        });

      // Update displayResults function
      function displayResults(results) {
        const resultsSection = document.getElementById("resultsSection");
        const tbody = document.getElementById("resultsBody");
        const noResults = document.querySelector(".no-results");
        const loading = document.getElementById("loading");
        const progressBarContainer = document.querySelector(
          ".progress-bar-container"
        );

        // Hide loading and progress
        loading.classList.add("hidden");
        progressBarContainer.classList.add("hidden");

        // Show results section
        resultsSection.classList.remove("hidden");

        // Clear previous results
        tbody.innerHTML = "";

        if (!results || results.length === 0) {
          noResults.classList.remove("hidden");
          return;
        }

        noResults.classList.add("hidden");
        results.forEach((result) => {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${escapeHtml(result.filename)}</td>
            <td>${escapeHtml(result.sheet)}</td>
            <td>${escapeHtml(result.cell)}</td>
            <td>${escapeHtml(result.value)}</td>
          `;
          tbody.appendChild(row);
        });

        // Store results for sorting/filtering
        window.searchResults = results;
      }

      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // Add this function for folder selection
      async function selectFolder() {
        try {
          const response = await fetch("http://localhost:3000/select-folder", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          const data = await response.json();
          if (data.path) {
            document.getElementById("folderPath").value = data.path;
          }
        } catch (error) {
          console.error("Error selecting folder:", error);
          // Show error in the UI
          const errorDiv = document.getElementById("error");
          errorDiv.textContent =
            "Failed to open folder selection dialog. Make sure the folder service is running.";
          errorDiv.classList.remove("hidden");
        }
      }

      // Add this: Update file name display
      document.getElementById("file").addEventListener("change", function (e) {
        const fileName = e.target.files[0]?.name || "No file chosen";
        document.getElementById("fileNameDisplay").textContent = fileName;
      });

      // Add debounce function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Update the filtering functionality
      document.addEventListener("DOMContentLoaded", function () {
        let currentSort = { column: null, direction: "asc" };
        const MIN_FILTER_LENGTH = 2; // Minimum characters before filtering
        let cachedResults = []; // Cache for filtered results

        // Sorting functionality
        document.querySelectorAll(".sortable").forEach((header) => {
          header.addEventListener("click", () => {
            const column = header.dataset.sort;

            // Update sort direction
            if (currentSort.column === column) {
              currentSort.direction =
                currentSort.direction === "asc" ? "desc" : "asc";
            } else {
              currentSort.column = column;
              currentSort.direction = "asc";
            }

            // Update sort icons
            document.querySelectorAll(".sort-icon").forEach((icon) => {
              icon.textContent = "‚Üï";
            });
            header.querySelector(".sort-icon").textContent =
              currentSort.direction === "asc" ? "‚Üë" : "‚Üì";

            // Sort and display results
            if (window.searchResults) {
              applyFiltersAndSort();
            }
          });
        });

        // Filtering functionality
        const filterInput = document.getElementById("filterInput");
        const filterColumn = document.getElementById("filterColumn");
        const resultsSection = document.getElementById("resultsSection");
        const tbody = document.getElementById("resultsBody");
        const noResults = document.querySelector(".no-results");

        function applyFiltersAndSort() {
          if (!window.searchResults) return;

          const filterText = filterInput.value.toLowerCase();
          const column = filterColumn.value;

          // Skip filtering if text is too short
          if (filterText.length > 0 && filterText.length < MIN_FILTER_LENGTH) {
            return;
          }

          // Start with all results if no filter, or use cached results
          let filteredResults =
            filterText.length >= MIN_FILTER_LENGTH
              ? cachedResults
              : [...window.searchResults];

          // Apply filter
          if (filterText.length >= MIN_FILTER_LENGTH) {
            filteredResults = window.searchResults.filter((result) => {
              if (column === "all") {
                // Optimize by checking length first and using early return
                return Object.values(result).some((value) => {
                  const strValue = String(value).toLowerCase();
                  return strValue.includes(filterText);
                });
              }
              return String(result[column]).toLowerCase().includes(filterText);
            });
            cachedResults = filteredResults; // Cache the filtered results
          }

          // Apply sort if needed
          if (currentSort.column) {
            filteredResults.sort((a, b) => {
              let valueA = String(a[currentSort.column]).toLowerCase();
              let valueB = String(b[currentSort.column]).toLowerCase();
              return currentSort.direction === "asc"
                ? valueA.localeCompare(valueB)
                : valueB.localeCompare(valueA);
            });
          }

          // Update UI
          updateResultsTable(filteredResults);
        }

        function updateResultsTable(results) {
          tbody.innerHTML = "";

          if (results.length === 0) {
            noResults.classList.remove("hidden");
            return;
          }

          noResults.classList.add("hidden");
          const fragment = document.createDocumentFragment();

          results.forEach((result) => {
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>${escapeHtml(result.filename)}</td>
              <td>${escapeHtml(result.sheet)}</td>
              <td>${escapeHtml(result.cell)}</td>
              <td>${escapeHtml(result.value)}</td>
            `;
            fragment.appendChild(row);
          });

          tbody.appendChild(fragment);
        }

        // Debounce the filter function
        const debouncedFilter = debounce(() => {
          applyFiltersAndSort();
        }, 300); // 300ms delay

        filterInput.addEventListener("input", () => {
          const filterText = filterInput.value.toLowerCase();

          // Clear results if filter text is too short
          if (filterText.length > 0 && filterText.length < MIN_FILTER_LENGTH) {
            tbody.innerHTML = "";
            noResults.classList.remove("hidden");
            noResults.textContent = `Please enter at least ${MIN_FILTER_LENGTH} characters to search`;
            return;
          }

          debouncedFilter();
        });

        filterColumn.addEventListener("change", () => {
          cachedResults = []; // Clear cache when column changes
          applyFiltersAndSort();
        });
      });
    </script>
  </body>
</html>
