<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ExcelSeeker</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <div class="theme-switch">
      <button
        id="restartButton"
        class="theme-toggle-btn"
        aria-label="Restart services"
        title="Restart services and reload page"
      >
        <svg
          class="theme-icon"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="M23 4v6h-6"></path>
          <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
        </svg>
      </button>
      <button
        id="themeToggle"
        class="theme-toggle-btn"
        aria-label="Toggle theme"
      >
        <svg
          class="theme-icon sun-icon"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        <svg
          class="theme-icon moon-icon"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      </button>
    </div>

    <div class="container">
      <header>
        <h1>ExcelSeeker</h1>
        <p>Search through Excel files with ease</p>
      </header>

      <main>
        <div class="upload-section">
          <form id="searchForm" enctype="multipart/form-data">
            <div class="search-type">
              <label>How would you like to search?</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input
                    type="radio"
                    id="singleFile"
                    name="searchType"
                    value="file"
                  />
                  <label for="singleFile">
                    <i class="icon">üìÑ</i>
                    Single File
                  </label>
                  <span class="check-icon">‚úì</span>
                </div>
                <div class="radio-option">
                  <input
                    type="radio"
                    id="folder"
                    name="searchType"
                    value="folder"
                    checked
                  />
                  <label for="folder">
                    <i class="icon">üìÅ</i>
                    Folder
                  </label>
                  <span class="check-icon">‚úì</span>
                </div>
              </div>
            </div>

            <div id="fileInput" class="file-input hidden">
              <label>Select Excel File</label>
              <div class="custom-file-input">
                <input type="file" id="file" name="file" accept=".xls" />
                <label for="file" class="custom-file-label">
                  <span id="fileNameDisplay">No file chosen</span>
                  <div class="browse-btn">Browse</div>
                </label>
              </div>
            </div>

            <div id="folderInput" class="file-input">
              <label for="folderPath">Select Folder</label>
              <div class="folder-input-group">
                <input
                  type="text"
                  id="folderPath"
                  name="folderPath"
                  placeholder="Choose a folder containing .xls files"
                  readonly
                  required
                />
                <button
                  type="button"
                  id="selectFolderBtn"
                  onclick="selectFolder()"
                >
                  Browse...
                </button>
              </div>
              <p class="help-text">
                All .xls files in the selected folder will be searched
              </p>
            </div>

            <div class="search-container">
              <input
                type="text"
                id="searchText"
                name="search_text"
                placeholder="Enter search text..."
                required
              />
              <div class="search-mode">
                <label class="radio-label">
                  <input
                    type="radio"
                    name="search_mode"
                    value="exact"
                    checked
                  />
                  <span>Exact phrase</span>
                </label>
                <label class="radio-label">
                  <input type="radio" name="search_mode" value="any" />
                  <span>Any keywords</span>
                </label>
                <label class="radio-label">
                  <input type="radio" name="search_mode" value="all" />
                  <span>All keywords</span>
                </label>
              </div>
            </div>

            <button type="submit">Search</button>
          </form>
        </div>

        <div id="loading" class="loading hidden">
          <div class="spinner"></div>
          <p>Searching...</p>
          <p id="progress" class="progress-text"></p>
          <div class="progress-bar-container">
            <div class="progress-bar"></div>
            <div class="progress-text">0%</div>
          </div>
          <button type="button" id="cancelSearch" class="cancel-button">
            Cancel Search
          </button>
        </div>

        <div class="results-section" id="resultsSection">
          <div class="results-header">
            <h2>Search Results</h2>
          </div>
          <div class="results-controls">
            <div class="filter-group">
              <input
                type="text"
                id="filterInput"
                class="filter-input"
                placeholder="Filter results..."
                onkeyup="filterResults()"
              />
              <select
                id="filterColumn"
                class="filter-select"
                onchange="filterResults()"
              >
                <option value="all">All Columns</option>
                <option value="filename">File Name</option>
                <option value="sheet">Sheet</option>
                <option value="cell">Cell</option>
                <option value="value">Value</option>
              </select>
            </div>
          </div>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th class="sortable" onclick="sortTable(0)">
                    File <span class="sort-icon">‚Üï</span>
                  </th>
                  <th class="sortable" onclick="sortTable(1)">
                    Sheet <span class="sort-icon">‚Üï</span>
                  </th>
                  <th class="sortable" onclick="sortTable(2)">
                    Cell <span class="sort-icon">‚Üï</span>
                  </th>
                  <th class="sortable" onclick="sortTable(3)">
                    Value <span class="sort-icon">‚Üï</span>
                  </th>
                </tr>
              </thead>
              <tbody id="resultsBody"></tbody>
            </table>
          </div>
        </div>

        <div id="skippedFiles" class="skipped-files hidden">
          <div class="skipped-header">
            <h3>Skipped Files</h3>
            <div class="skipped-controls">
              <div class="filter-group">
                <input
                  type="text"
                  id="skipFilterInput"
                  class="filter-input"
                  placeholder="Filter skipped files..."
                />
                <select id="skipFilterColumn" class="filter-select">
                  <option value="all">All Columns</option>
                  <option value="filename">File Name</option>
                  <option value="reason">Error Reason</option>
                </select>
              </div>
              <button
                type="button"
                onclick="clearSkipList()"
                class="secondary-button"
                title="Clear the list of skipped files"
              >
                Clear Skip List
              </button>
              <button
                type="button"
                onclick="exportSkipList()"
                class="secondary-button"
                title="Export skipped files list as CSV"
              >
                Export List
              </button>
            </div>
          </div>
          <div class="skipped-files-content">
            <table class="skipped-table">
              <thead>
                <tr>
                  <th class="sortable" onclick="sortSkippedFiles(0)">
                    File Name <span class="sort-icon">‚Üï</span>
                  </th>
                  <th class="sortable" onclick="sortSkippedFiles(1)">
                    Error Reason <span class="sort-icon">‚Üï</span>
                  </th>
                </tr>
              </thead>
              <tbody id="skippedFilesList"></tbody>
            </table>
          </div>
        </div>
      </main>
    </div>

    <script>
      // Theme toggle functionality
      const themeToggle = document.getElementById("themeToggle");
      const html = document.documentElement;

      // Check for saved theme preference
      const savedTheme = localStorage.getItem("theme") || "light";
      html.setAttribute("data-theme", savedTheme);
      updateThemeIcon(savedTheme === "dark");

      themeToggle.addEventListener("click", () => {
        const currentTheme = html.getAttribute("data-theme");
        const newTheme = currentTheme === "light" ? "dark" : "light";
        html.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);
        updateThemeIcon(newTheme === "dark");
      });

      function updateThemeIcon(isDark) {
        const sunIcon = themeToggle.querySelector(".sun-icon");
        const moonIcon = themeToggle.querySelector(".moon-icon");
        if (isDark) {
          sunIcon.style.display = "none";
          moonIcon.style.display = "block";
        } else {
          sunIcon.style.display = "block";
          moonIcon.style.display = "none";
        }
      }

      // Toggle between file and folder input
      document.querySelectorAll('input[name="searchType"]').forEach((radio) => {
        radio.addEventListener("change", (e) => {
          const fileInput = document.getElementById("fileInput");
          const folderInput = document.getElementById("folderInput");
          const fileElement = document.getElementById("file");
          const folderElement = document.getElementById("folderPath");

          if (e.target.value === "file") {
            fileInput.classList.remove("hidden");
            folderInput.classList.add("hidden");
            fileElement.required = true;
            folderElement.required = false;
          } else {
            fileInput.classList.add("hidden");
            folderInput.classList.remove("hidden");
            fileElement.required = false;
            folderElement.required = true;

            // Restore the last folder path when switching to folder mode
            const lastFolderPath = sessionStorage.getItem("lastFolderPath");
            if (lastFolderPath) {
              folderElement.value = lastFolderPath;
            }
          }
        });
      });

      // Add this to set initial required states
      document.addEventListener("DOMContentLoaded", () => {
        const fileElement = document.getElementById("file");
        const folderElement = document.getElementById("folderPath");
        const searchType = document.querySelector(
          'input[name="searchType"]:checked'
        ).value;

        fileElement.required = searchType === "file";
        folderElement.required = searchType === "folder";
      });

      async function handleFolderSearch(folderPath, searchText) {
        const loading = document.getElementById("loading");
        const progress = document.getElementById("progress");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarContainer = document.querySelector(
          ".progress-bar-container"
        );
        const progressText = document.querySelector(
          ".progress-bar-container .progress-text"
        );
        const resultsSection = document.getElementById("resultsSection");
        const cancelButton = document.getElementById("cancelSearch");

        // Show loading and progress bar
        loading.classList.remove("hidden");
        progressBarContainer.classList.remove("hidden");
        resultsSection.classList.add("hidden");
        progress.textContent = "Preparing to search...";
        progressBar.style.width = "0%";
        progressText.textContent = "0%";
        cancelButton.style.display = "block";

        // Get the selected search mode
        const searchMode = document.querySelector(
          'input[name="search_mode"]:checked'
        ).value;

        // Create EventSource for progress updates
        const eventSource = new EventSource(
          `/search_folder?folder_path=${encodeURIComponent(
            folderPath
          )}&search_text=${encodeURIComponent(
            searchText
          )}&search_mode=${searchMode}`
        );

        handleEventSource(eventSource);
      }

      // Add error display function
      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error";
        errorDiv.textContent = message;

        const resultsSection = document.getElementById("resultsSection");
        resultsSection.insertAdjacentElement("beforebegin", errorDiv);

        // Remove error after 5 seconds
        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
      }

      function showMessage(message) {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message";
        messageDiv.textContent = message;

        const resultsSection = document.getElementById("resultsSection");
        resultsSection.insertAdjacentElement("beforebegin", messageDiv);

        // Remove message after 5 seconds
        setTimeout(() => {
          messageDiv.remove();
        }, 5000);
      }

      // Update the form submit handler
      document
        .getElementById("searchForm")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const form = e.target;
          const formData = new FormData(form);
          const loading = document.getElementById("loading");
          const progress = document.getElementById("progress");
          const resultsSection = document.getElementById("resultsSection");
          const searchType = formData.get("searchType");

          // Remove any existing error messages
          document
            .querySelectorAll(".error")
            .forEach((error) => error.remove());

          // Reset and show loading
          loading.classList.remove("hidden");
          resultsSection.classList.add("hidden");
          progress.textContent = "";

          try {
            if (searchType === "folder") {
              const folderPath = formData.get("folderPath");
              if (!folderPath) {
                throw new Error("Please select a folder");
              }
              await handleFolderSearch(folderPath, formData.get("search_text"));
            } else {
              const file = formData.get("file");
              if (!file || !file.name) {
                throw new Error("Please select a file");
              }

              const response = await fetch("/search", {
                method: "POST",
                body: formData,
              });

              const data = await response.json();

              if (!response.ok) {
                throw new Error(data.error || "An error occurred");
              }

              if (data.error) {
                throw new Error(data.error);
              }

              loading.classList.add("hidden");
              if (data && data.length > 0) {
                displayResults(data);
              } else {
                showError("No results found in the selected file.");
              }
            }
          } catch (err) {
            loading.classList.add("hidden");
            showError(
              err.message || "An error occurred while processing the request"
            );
          }
        });

      // Update displayResults function
      function displayResults(results) {
        const tbody = document.getElementById("resultsBody");
        const resultsSection = document.getElementById("resultsSection");

        // Clear existing content
        tbody.innerHTML = "";

        if (!results || results.length === 0) {
          resultsSection.classList.add("hidden");
          showMessage("No results found.");
          return;
        }

        // Show the results section
        resultsSection.classList.remove("hidden");

        // Group results by filename
        const groupedResults = {};
        results.forEach((result) => {
          if (!groupedResults[result.filename]) {
            groupedResults[result.filename] = [];
          }
          groupedResults[result.filename].push(result);
        });

        // Add each group to the table
        Object.entries(groupedResults).forEach(
          ([filename, fileResults], groupIndex) => {
            // Add group header
            const headerRow = document.createElement("tr");
            headerRow.className = "group-header";
            headerRow.innerHTML = `
            <td colspan="4">
              <div class="file-group-header">
                <a href="#" 
                   onclick="openFile('${escapeHtml(
                     fileResults[0].filepath
                   )}'); return false;" 
                   class="file-link" 
                   title="Click to open file">
                  ${escapeHtml(filename)}
                </a>
                <span class="match-count">${fileResults.length} match${
              fileResults.length > 1 ? "es" : ""
            }</span>
              </div>
            </td>
          `;
            tbody.appendChild(headerRow);

            // Add results for this file
            fileResults.forEach((result) => {
              const row = document.createElement("tr");
              row.className = "group-item";
              row.innerHTML = `
              <td></td>
            <td>${escapeHtml(result.sheet)}</td>
            <td>${escapeHtml(result.cell)}</td>
            <td>${escapeHtml(result.value)}</td>
          `;
              tbody.appendChild(row);
            });

            // Add separator after each group except the last one
            if (groupIndex < Object.keys(groupedResults).length - 1) {
              const separatorRow = document.createElement("tr");
              separatorRow.className = "group-separator";
              separatorRow.innerHTML = '<td colspan="4"></td>';
              tbody.appendChild(separatorRow);
            }
          }
        );

        // Store results for sorting/filtering
        window.searchResults = results;
      }

      function openFile(filepath) {
        fetch("/open-file", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ filepath: filepath }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              showError(data.error);
            }
          })
          .catch((error) => {
            console.error("Error opening file:", error);
            showError("Failed to open file");
          });
      }

      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // Add this function for folder selection
      async function selectFolder() {
        try {
          const response = await fetch("http://localhost:3000/select-folder", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          const data = await response.json();
          if (data.path) {
            document.getElementById("folderPath").value = data.path;
            // Store the selected path in sessionStorage
            sessionStorage.setItem("lastFolderPath", data.path);
          }
        } catch (error) {
          console.error("Error selecting folder:", error);
          // Show error in the UI
          const errorDiv = document.getElementById("error");
          errorDiv.textContent =
            "Failed to open folder selection dialog. Make sure the folder service is running.";
          errorDiv.classList.remove("hidden");
        }
      }

      // Add this to restore the folder path on page load/restart
      document.addEventListener("DOMContentLoaded", () => {
        const lastFolderPath = sessionStorage.getItem("lastFolderPath");
        if (lastFolderPath) {
          document.getElementById("folderPath").value = lastFolderPath;
        }

        // Add event listener for the restart button to preserve path
        document
          .getElementById("restartButton")
          .addEventListener("click", async () => {
            try {
              // Disable the restart button
              const restartButton = document.getElementById("restartButton");
              restartButton.disabled = true;

              // Show a loading message
              showMessage("Stopping services...");

              // Clean up any existing search
              if (activeEventSource) {
                activeEventSource.close();
                activeEventSource = null;
              }

              // Call the restart endpoint
              const response = await fetch("/restart-services", {
                method: "POST",
              });

              if (!response.ok) {
                throw new Error("Failed to restart services");
              }

              showMessage("Starting services...");

              // Reload the page after a delay
              setTimeout(() => {
                window.location.reload();
              }, 3000);
            } catch (error) {
              showError("Failed to restart services: " + error.message);
              // Re-enable the restart button on error
              document.getElementById("restartButton").disabled = false;
            }
          });
      });

      // Add this: Update file name display
      document.getElementById("file").addEventListener("change", function (e) {
        const fileName = e.target.files[0]?.name || "No file chosen";
        document.getElementById("fileNameDisplay").textContent = fileName;
      });

      // Add debounce function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Add sorting and filtering functionality
      let currentSort = { column: -1, direction: 1 };
      let currentFilter = { text: "", column: "all" };

      function sortTable(columnIndex) {
        const tbody = document.getElementById("resultsBody");
        const rows = Array.from(tbody.getElementsByTagName("tr"));

        // Update sort direction
        if (currentSort.column === columnIndex) {
          currentSort.direction *= -1;
        } else {
          currentSort.direction = 1;
        }
        currentSort.column = columnIndex;

        // Update sort icons
        document.querySelectorAll(".sort-icon").forEach((icon) => {
          icon.textContent = "‚Üï";
        });
        const currentIcon =
          document.querySelectorAll(".sort-icon")[columnIndex];
        currentIcon.textContent = currentSort.direction === 1 ? "‚Üì" : "‚Üë";

        // Sort rows
        rows.sort((a, b) => {
          const aValue = a.cells[columnIndex].textContent.trim().toLowerCase();
          const bValue = b.cells[columnIndex].textContent.trim().toLowerCase();
          return aValue.localeCompare(bValue) * currentSort.direction;
        });

        // Clear and re-append sorted rows while maintaining visibility
        tbody.innerHTML = "";
        rows.forEach((row) => {
          tbody.appendChild(row);
        });

        // Reapply current filter if exists
        if (currentFilter.text) {
          filterResults();
        }
      }

      function filterResults() {
        const filterText = document
          .getElementById("filterInput")
          .value.toLowerCase();
        const filterColumn = document.getElementById("filterColumn").value;
        const tbody = document.getElementById("resultsBody");
        const rows = Array.from(tbody.getElementsByTagName("tr"));

        // Store current filter state
        currentFilter.text = filterText;
        currentFilter.column = filterColumn;

        // Show all rows if filter is empty
        if (!filterText) {
          rows.forEach((row) => (row.style.display = ""));
          return;
        }

        // Apply filter
        rows.forEach((row) => {
          let text = "";
          if (filterColumn === "all") {
            text = row.textContent.toLowerCase();
          } else {
            const columnIndex = {
              filename: 0,
              sheet: 1,
              cell: 2,
              value: 3,
            }[filterColumn];
            text = row.cells[columnIndex].textContent.toLowerCase();
          }
          row.style.display = text.includes(filterText) ? "" : "none";
        });

        // Update visibility of no results message
        const visibleRows = rows.filter((row) => row.style.display !== "none");
        updateResultsTable(visibleRows);
      }

      // Add input event listener for real-time filtering
      document.addEventListener("DOMContentLoaded", function () {
        const filterInput = document.getElementById("filterInput");
        const filterColumn = document.getElementById("filterColumn");

        // Use input event instead of keyup for better handling of all input types
        filterInput.addEventListener("input", filterResults);
        filterColumn.addEventListener("change", filterResults);
      });

      function updateResultsTable(filteredRows) {
        const resultsSection = document.getElementById("resultsSection");
        const noResults = document.querySelector(".no-results");

        if (filteredRows.length === 0) {
          if (!noResults) {
            const noResultsDiv = document.createElement("div");
            noResultsDiv.className = "no-results";
            noResultsDiv.textContent = "No matching results found";
            resultsSection.appendChild(noResultsDiv);
          }
        } else {
          if (noResults) {
            noResults.remove();
          }
        }
      }

      document.addEventListener("DOMContentLoaded", function () {
        const form = document.getElementById("searchForm");
        form.addEventListener("submit", handleSubmit);

        // Setup file input change handler
        const fileInput = document.getElementById("fileInput");
        fileInput.addEventListener("change", function () {
          const label = document.querySelector(".file-label");
          label.textContent = this.files[0]
            ? this.files[0].name
            : "Choose file";
        });

        // Add cancel button click handler
        document
          .getElementById("cancelSearch")
          .addEventListener("click", function () {
            if (currentSearchId) {
              console.log(
                "Cancel button clicked, cancelling search:",
                currentSearchId
              );
              cancelSearch();
            }
          });
      });

      async function handleSubmit(event) {
        event.preventDefault();

        const searchText = document.getElementById("searchText").value.trim();
        const searchMode = document.querySelector(
          'input[name="search_mode"]:checked'
        ).value;
        const fileInput = document.getElementById("fileInput");
        const folderPath = document.getElementById("folderPath").value.trim();

        if (!searchText) {
          showError("Please enter search text");
          return;
        }

        // Show loading state and hide results
        const loadingDiv = document.getElementById("loading");
        loadingDiv.classList.remove("hidden");
        document.getElementById("resultsSection").classList.add("hidden");
        document.getElementById("error").style.display = "none";

        const formData = new FormData();
        formData.append("search_text", searchText);
        formData.append("search_mode", searchMode);

        try {
          if (folderPath) {
            await handleFolderSearch(folderPath, searchText);
          } else if (fileInput.files.length > 0) {
            formData.append("file", fileInput.files[0]);
            const response = await fetch("/search", {
              method: "POST",
              body: formData,
            });

            const data = await response.json();
            if (response.ok) {
              displayResults(data);
            } else {
              showError(data.error || "An error occurred while searching");
            }
            // Hide cancel button for single file search
            document.getElementById("cancelSearch").style.display = "none";
          } else {
            showError("Please select a file or folder to search");
          }
        } catch (error) {
          showError("An error occurred while searching");
          console.error("Search error:", error);
        }
      }

      // Global state
      let currentSearchId = null;
      let activeEventSource = null;

      function updateProgress(data) {
        const progressBar = document.querySelector(".progress-bar");
        const progressText = document.querySelector(".progress-text");
        const progress = (data.processed / data.total) * 100;
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${Math.round(progress)}%`;
      }

      function handleEventSource(eventSource) {
        activeEventSource = eventSource;
        const loadingDiv = document.getElementById("loading");
        const cancelButton = document.getElementById("cancelSearch");
        const progressText = document.getElementById("progress");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarText = document.querySelector(
          ".progress-bar-container .progress-text"
        );
        const resultsSection = document.getElementById("resultsSection");

        loadingDiv.classList.remove("hidden");
        cancelButton.style.display = "block";

        eventSource.onmessage = function (event) {
          const data = JSON.parse(event.data);
          console.log("Received data:", data); // Debug log

          if (data.error) {
            eventSource.close();
            loadingDiv.classList.add("hidden");
            showError(data.error);
            return;
          }

          if (data.search_id) {
            currentSearchId = data.search_id;
            return;
          }

          if (data.type === "progress") {
            const percentage = Math.round((data.processed / data.total) * 100);
            // Update main progress text
            progressText.textContent = `${percentage}%`;
            // Update progress bar and its text
            progressBar.style.width = `${percentage}%`;
            progressBarText.textContent = `${percentage}%`;
            // Update the file details
            document.querySelector(
              "#loading p:nth-child(3)"
            ).textContent = `Processing: ${data.current_file} (${data.processed}/${data.total} files, ${data.results_found} results found)`;
          } else if (data.type === "complete") {
            console.log("Search complete:", data); // Debug log
            eventSource.close();
            loadingDiv.classList.add("hidden");

            // Display results if any
            if (data.results && data.results.length > 0) {
              displayResults(data.results);
              resultsSection.classList.remove("hidden");
            } else {
              showMessage("No results found.");
            }

            // Display skipped files if any
            if (data.skipped_files && data.skipped_files.length > 0) {
              displaySkippedFiles(data.skipped_files);
            }
          } else if (data.type === "cancelled") {
            console.log("Search cancelled"); // Debug log
            eventSource.close();
            loadingDiv.classList.add("hidden");

            // Display partial results if any
            if (data.results && data.results.length > 0) {
              showMessage("Search cancelled. Showing partial results.");
              displayResults(data.results);
              resultsSection.classList.remove("hidden");

              // Display skipped files if any
              if (data.skipped_files && data.skipped_files.length > 0) {
                displaySkippedFiles(data.skipped_files);
              }
            } else {
              showMessage("Search cancelled. No results found yet.");
            }
            cleanupSearch();
          }
        };

        eventSource.onerror = function (event) {
          console.error("EventSource error:", event); // Debug log
          eventSource.close();
          loadingDiv.classList.add("hidden");
          showError("Connection error occurred. Please try again.");
          cleanupSearch();
        };
      }

      function cleanupSearch() {
        if (activeEventSource) {
          console.log("Closing event source");
          activeEventSource.close();
          activeEventSource = null;
        }

        const loadingDiv = document.getElementById("loading");
        const cancelButton = document.getElementById("cancelSearch");
        const progressBar = document.querySelector(".progress-bar");
        const progressBarText = document.querySelector(".progress-text");

        loadingDiv.classList.add("hidden");
        cancelButton.style.display = "none";
        progressBar.style.width = "0%";
        progressBarText.textContent = "0%";
        currentSearchId = null;
      }

      async function cancelSearch() {
        if (!currentSearchId) {
          console.log("No active search to cancel");
          return;
        }

        console.log("Attempting to cancel search:", currentSearchId);
        document.getElementById("progress").textContent =
          "Cancelling search...";

        try {
          const response = await fetch(`/cancel-search/${currentSearchId}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          const data = await response.json();
          console.log("Cancel response:", data);

          if (!response.ok) {
            showError(data.error || "Failed to cancel search");
            // Clean up anyway if the search is not found
            if (response.status === 404) {
              cleanupSearch();
            }
          } else {
            // Don't clean up here - wait for the cancelled event from SSE
            console.log("Cancel request successful");
          }
        } catch (error) {
          console.error("Error cancelling search:", error);
          showError("Failed to cancel search");
        }
      }

      function displaySkippedFiles(skippedFiles) {
        const skippedFilesDiv = document.getElementById("skippedFiles");
        const skippedFilesList = document.getElementById("skippedFilesList");

        // Clear existing content
        skippedFilesList.innerHTML = "";

        if (skippedFiles && skippedFiles.length > 0) {
          // Group skipped files by directory path
          const groupedSkipped = {};
          skippedFiles.forEach((file) => {
            // Split the file path into directory and filename
            const pathParts = file.file.split("/");
            const filename = pathParts.pop();
            const dirPath = pathParts.join("/");

            if (!groupedSkipped[dirPath]) {
              groupedSkipped[dirPath] = [];
            }
            groupedSkipped[dirPath].push({ ...file, filename });
          });

          // Add each group to the table
          Object.entries(groupedSkipped).forEach(
            ([dirPath, fileErrors], groupIndex) => {
              // Add group header
              const headerRow = document.createElement("tr");
              headerRow.className = "group-header";
              headerRow.innerHTML = `
              <td colspan="2">
                <div class="file-group-header">
                  <div class="path-info">
                    <span class="directory-path">${dirPath || "/"}</span>
                    <span class="match-count">${fileErrors.length} file${
                fileErrors.length > 1 ? "s" : ""
              }</span>
                  </div>
                </div>
              </td>
            `;
              skippedFilesList.appendChild(headerRow);

              // Add errors for this directory
              fileErrors.forEach((error) => {
                const row = document.createElement("tr");
                row.className = "group-item";
                const fileName =
                  typeof error.filename === "string"
                    ? error.filename
                    : error.file;
                const reason =
                  typeof error.reason === "object"
                    ? error.reason.reason
                    : error.reason;
                row.innerHTML = `
                <td class="file-name">${escapeHtml(fileName)}</td>
                <td class="file-reason">${escapeHtml(reason)}</td>
              `;
                skippedFilesList.appendChild(row);
              });

              // Add separator after each group except the last one
              if (groupIndex < Object.keys(groupedSkipped).length - 1) {
                const separatorRow = document.createElement("tr");
                separatorRow.className = "group-separator";
                separatorRow.innerHTML = '<td colspan="2"></td>';
                skippedFilesList.appendChild(separatorRow);
              }
            }
          );

          // Show the skipped files section
          skippedFilesDiv.classList.remove("hidden");

          // Add event listeners for filtering
          document
            .getElementById("skipFilterInput")
            .addEventListener("input", filterSkippedFiles);
          document
            .getElementById("skipFilterColumn")
            .addEventListener("change", filterSkippedFiles);
        } else {
          // Hide the section if no skipped files
          skippedFilesDiv.classList.add("hidden");
        }
      }

      async function clearSkipList() {
        try {
          const response = await fetch("/skip-list", {
            method: "DELETE",
          });

          const data = await response.json();
          if (response.ok) {
            document.getElementById("skippedFiles").classList.add("hidden");
            showMessage("Skip list cleared successfully");
          } else {
            showError(data.error || "Failed to clear skip list");
          }
        } catch (error) {
          showError("Failed to clear skip list");
          console.error("Error clearing skip list:", error);
        }
      }

      // Add restart functionality
      document
        .getElementById("restartButton")
        .addEventListener("click", async () => {
          try {
            // Disable the restart button
            const restartButton = document.getElementById("restartButton");
            restartButton.disabled = true;

            // Show a loading message
            showMessage("Stopping services...");

            // Clean up any existing search
            if (activeEventSource) {
              activeEventSource.close();
              activeEventSource = null;
            }

            // Call the restart endpoint
            const response = await fetch("/restart-services", {
              method: "POST",
            });

            if (!response.ok) {
              throw new Error("Failed to restart services");
            }

            showMessage("Starting services...");

            // Reload the page after a delay
            setTimeout(() => {
              window.location.reload();
            }, 3000);
          } catch (error) {
            showError("Failed to restart services: " + error.message);
            // Re-enable the restart button on error
            document.getElementById("restartButton").disabled = false;
          }
        });

      // Add to your existing JavaScript
      let skipCurrentSort = { column: -1, direction: 1 };
      let skipCurrentFilter = { text: "", column: "all" };

      function sortSkippedFiles(columnIndex) {
        const tbody = document.getElementById("skippedFilesList");
        const rows = Array.from(tbody.getElementsByTagName("tr"));

        // Update sort direction
        if (skipCurrentSort.column === columnIndex) {
          skipCurrentSort.direction *= -1;
        } else {
          skipCurrentSort.direction = 1;
        }
        skipCurrentSort.column = columnIndex;

        // Update sort icons
        document
          .querySelectorAll(".skipped-table .sort-icon")
          .forEach((icon) => {
            icon.textContent = "‚Üï";
          });
        const currentIcon = document.querySelectorAll(
          ".skipped-table .sort-icon"
        )[columnIndex];
        currentIcon.textContent = skipCurrentSort.direction === 1 ? "‚Üì" : "‚Üë";

        // Sort rows
        rows.sort((a, b) => {
          const aValue = a.cells[columnIndex].textContent.trim().toLowerCase();
          const bValue = b.cells[columnIndex].textContent.trim().toLowerCase();
          return aValue.localeCompare(bValue) * skipCurrentSort.direction;
        });

        // Clear and re-append sorted rows
        tbody.innerHTML = "";
        rows.forEach((row) => tbody.appendChild(row));
      }

      function filterSkippedFiles() {
        const filterText = document
          .getElementById("skipFilterInput")
          .value.toLowerCase();
        const filterColumn = document.getElementById("skipFilterColumn").value;
        const tbody = document.getElementById("skippedFilesList");
        const groups = Array.from(tbody.getElementsByClassName("group-header"));

        groups.forEach((header) => {
          let groupVisible = false;
          let currentGroup = header;
          const items = [];

          // Collect all items in this group
          while (
            currentGroup.nextElementSibling &&
            !currentGroup.nextElementSibling.classList.contains("group-header")
          ) {
            if (
              currentGroup.nextElementSibling.classList.contains("group-item")
            ) {
              items.push(currentGroup.nextElementSibling);
            }
            currentGroup = currentGroup.nextElementSibling;
          }

          // Apply filter to group
          if (filterText === "") {
            // Show all when filter is empty
            header.style.display = "";
            items.forEach((item) => (item.style.display = ""));
            if (
              header.nextElementSibling?.classList.contains("group-separator")
            ) {
              header.nextElementSibling.style.display = "";
            }
            return;
          }

          items.forEach((item) => {
            let text = "";
            if (filterColumn === "all") {
              text =
                header.textContent.toLowerCase() +
                " " +
                item.textContent.toLowerCase();
            } else if (filterColumn === "filename") {
              text = item.querySelector(".file-name").textContent.toLowerCase();
            } else if (filterColumn === "reason") {
              text = item
                .querySelector(".file-reason")
                .textContent.toLowerCase();
            }

            const matches = text.includes(filterText);
            item.style.display = matches ? "" : "none";
            if (matches) groupVisible = true;
          });

          // Show/hide header and separator based on group visibility
          header.style.display = groupVisible ? "" : "none";
          if (
            header.nextElementSibling?.classList.contains("group-separator")
          ) {
            header.nextElementSibling.style.display = groupVisible
              ? ""
              : "none";
          }
        });
      }

      // Update the export function to handle path-based grouping
      function exportSkipList() {
        const skippedFilesList = document.getElementById("skippedFilesList");
        if (!skippedFilesList || !skippedFilesList.rows.length) {
          showMessage("No skipped files to export");
          return;
        }

        // Create CSV content
        let csvContent = "Path,File Name,Error Reason\n";
        let currentPath = "";

        Array.from(skippedFilesList.rows).forEach((row) => {
          if (row.classList.contains("group-header")) {
            // Get path from the header
            currentPath = row.querySelector(".directory-path").textContent;
          } else if (row.classList.contains("group-item")) {
            // Get filename and error reason from the item row
            const fileName = row.querySelector(".file-name").textContent;
            const reason = row.querySelector(".file-reason").textContent;
            // Properly escape fields that might contain commas
            const escapedPath = `"${currentPath.replace(/"/g, '""')}"`;
            const escapedFileName = `"${fileName.replace(/"/g, '""')}"`;
            const escapedReason = `"${reason.replace(/"/g, '""')}"`;
            csvContent += `${escapedPath},${escapedFileName},${escapedReason}\n`;
          }
        });

        // Create and trigger download
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "skipped_files.csv");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showMessage("Skipped files list exported successfully");
      }

      // Add these styles for path-based display
      const pathStyles = document.createElement("style");
      pathStyles.textContent = `
        .path-info {
          display: flex;
          flex-direction: column;
          gap: 0.25rem;
        }

        .directory-path {
          color: var(--subtext-color);
          font-size: 0.9em;
          font-family: monospace;
        }

        .file-name {
          font-weight: 500;
          padding-left: 2rem;
        }

        .group-header .match-count {
          color: var(--text-color);
          opacity: 0.7;
        }
      `;
      document.head.appendChild(pathStyles);
    </script>
  </body>
</html>
